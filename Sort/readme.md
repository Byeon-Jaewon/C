## 선택정렬
***
> selectionSort()함수를 보면, 첫번째 for문에서 min값에 i를 넣는다.   
> 이것은 현재 i값이 최솟값의 인덱스라고 가정하는 것이고,    
> 두번째 for문에서 i보다 1 더 큰 인덱스로 시작해서 j가 min보다 더 낮은 값을 갖는다면    
> j값을 min으로 저장하는 식으로 정렬을 진행한다.    
<pre> 비교횟수는 N^2/2이지만, 데이터 이동 횟수는 N번이 된다.</pre>
***
## 삽입정렬
***
> 첫번째 값이 아닌 두번째 값부터 시작.   
> InsertSort()함수에서 dummy변수에 i번째 데이터를 넣은 후 j에 i를 저장한다.   
> 현재 Buf[j-1]과 dummy값을 비교해, 배열 Buf에 있는 값이 현재 dummy값보다 크면   
> 현재의 Buf값을 한칸 뒤로 이동시키고 j를 감소시킨다.   
> 이 과정이 완료되면 다시 while문으로 돌아가고 dummy값이 Buf[j-1]보다 커지고   
> j가 0보다 클 때 계속 된다.
> 조건이 거짓이 되면 dummy값을 Buf[j]에 저장한다.
<pre>for문은 정렬할 데이터를 처음부터 끝까지 반복해서 찾는 부분이며
while문은 이미 정렬되어있는 데이터 중에서 
변수 dummy에 저장한 값이 들어갈 위치를 찾는 부분이다</pre>

***
## 버블정렬
***
> 두 개의 for문으로 구성.   
>    
> 첫번째 for문에서 전체 배열크기를 한바퀴 도는 조건을 정한다.   
> 두번째 for문에서 j는 1부터 i까지 반복하며 전체 데이터를 비교하며   
> Buf[j-1] > Buf[j]가 된다면 j-1과 j를 스왑해준다.
<pre>전체 데이터를 모두 비교하고 이동시키는 방법으로
최선의 경우(정렬되어 있을 때) 이동이 없지만
최악의 경우 모든 데이터가 이동한다.</pre>
***
## 쉘 정렬
***
> 첫 for문에서 0부터 시작하는 변수 h에 3을 곱하고 1을 더한값으로 증가시키면서   
>  h가 MAX보다 작아질 때까지 반복한다.   
> 조건식을 최초로 만족하는 h값은 121.
> 두번째 for 문에서 변수 i 에 h 값을 넣고 3으로 나눠가며   
> i가 MAX보다 작아질때 버퍼에 있는 값을 v에 넣고 변수 j에 i값을 대입한다.   
> while문에서 j가 h보다 크거나 같고, Buf[j-h]가 v보다 크다면,   
> Buf[j]에 Buf[j-h]를 넣고 j에 h값을 뺀 만큼을 다시 대입한 후 반복을 벗어난다.    
<pre>쉘정렬은 삽입정렬을 보완한 알고리즘으로 리스트를 
일정한 기준에 따라 분류하고, 
여러 부분리스트를 생성한 것을 삽입정렬을 이용하여 정렬하고,
모든 부분리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분리스트로 만든 후 반복한다.
부분리스트의 개수가 1이 될 때까지 반복한다.</pre>
*다시 정리할 것.

***
## 퀵정렬
***
> QuickSort함수에서 정렬대상 배열과, 맨 왼쪽의 인덱스, 맨 오른쪽의 인덱스를 입력 받는다.   
> 배열의 맨 오른쪽 값을 기준으로 두고, 기준값을 제외한 데이터들 중 다시 왼쪽과 오른쪽의 값을 정한다.   
> 기준을 제외한 데이터들 중 왼쪽의 값이 기준보다 크고, 오른쪽의 값이 기준보다 작은 값을 비교하며 찾은 후,   
> 둘의 위치를 바꿔준다.
> 이 때, 위치를 바꾼 두 데이터중 기준값보다 큰 수를 기준값보다 오른쪽에 놓기 위해 다시 두 값의 위치를 바꿔준다.
> 그 후 재귀호출을 통해 다시 기준값을 정하고 왼쪽부분과 오른쪽부분을 반복해서 정렬한다.