## 탐욕알고리즘
    
> 한빛전자에서는 2015년 하반기 출시 예정인 스마트폰 프로젝트를 진행하고 있다. 이미 스마트폰안에 운영체제를 포팅하는 작업은 끝났고 각종 앱을 포팅하는 업무만 남았다.   
> 출시 전까지 해결해야할 문제는 이 최신형 스마트폰의 메모리 공간에 최대한 앱을 탑재하고 앱이 처음 실행되는데 총 소요시간이 얼마나 되는지를 확인하는 일이다. 목적은 여러가지 앱을 탑재했을 때 앱 각각의 실행시간이 최소가 되어야 하기 때문이다.   
> 전체 메모리가 110k인 경우 OS가 10k를 사용하므로 실제 스마트폰 앱이 사용할 수 있는 메모리는 100k가 된다. 이 공간에 다른 앱들을 저장하되 가장 빠른 시간에 이 앱들이 실행되어야 하는 것이다.   
> 한정된 메모리 공간 안에서 다수의 작업이 가장 적은 소요시간으로 실행되어야 한다.
> 앱 각각은 단 한번만 실행되는 것이 아니라 여러번 실행될 수 있다.
   
- 입력파일의 이름은 input.txt
- 입력 데이터는 T개의 테스트케이스, 파일의 첫번째 행.
- 각 테스트의 첫번째 행에는 두정수 E, F **(1<=E<=F<=10000)** 가 주어진다.
- 각 테스트의 두번째 행에는 스마트폰에 포팅될 앱의 개수 N이 주어진다.
- 각 테스트의 세번째 행부터는 P **(1<=P<=50000)**와 W **(1<=W<=10000)**이 주어진다. P는 앱의 실행시간이고, W는 앱이 차지하는 메모리의 크기다.

- 출력파일의 이름은 output.txt
- 각 테스트에 주어진 메모리 크기를 갖는 앱들이 실행될때 소요되는 최소시간 출력
- 메모리 크기가 정확히 맞지않으면 -1을 출력
> 주어진 앱들이 실행될 때 차지하는 **메모리크기(W)**의 합이 **전체 메모리의 크기(F-E)**를 유지하면서 **실행시간(P)**를 최소로 유지.   
        
           
메모리 크기가 3, 4, 5인 앱들로 전체 메로리가 10이 되도록 만들기   
1차원 배열을 만들어 확인.   
| I | 0 | 1 | 2 | 3 | 5 | 6 | 7 | 8 | 9 | 10
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|---|
| S(I) | 0 | MAX |  MAX | MAX | MAX | MAX | MAX | MAX | MAX | MAX |   

S(I)는 I만큼 메모리를 갖도록 앱을 선택하는 방법 중 앱들의 전체 실행 시간이 최소가되는 경우의 값 저장.   
초기값은 충분히 큰 값을 저장한다.   
   
**메모리가 k**일때 *최소실행시간 p*, *메모리크기가 w*인 앱을 추가하면,    
W는 k+w가 되고, P는 S(k)+p가 된다.   
**저장되어있는 S(k+w)보다 S(k)+p가 작다면** S(K+w)의 값을 S(k)+p로 갱신해준다.
   

   반복문을 사용하여 배열 S를 채워주고 만약 최종적인 배열에서 S(F-E)값이 MAX로 남아있다면 원하는 메모리를 사용할 수 없는 경우가 되기 때문에 -1을 출력한다.   

***
## 세포의 자기 증식 프로젝트
> 한빛전자에서는 지난번 한국생명과학협회의 줄기 세포 연구와 관련한 방정식을 간소화하는 프로그램 덕분에 상당한 호평을 받게 됐다. 프로젝트 이후 한빛전자는 본격적으로 줄기세포 연구에 관한 프로젝트를 진행하게 됐다.   
> 줄기세포는 자기 증식 기능이 있다. 자기증식을 하는 알파세포는 총 5개의 DNA가 있는데 3번째 DNA에만 정보가 저장되어있고 다른 DNA에는 정보가 없다.
> DNA3에 있던 정보가 DNA2와 DNA4로 분할되어 이동하고 DNA3자신의 정보는 사라지게 되고 이와 같은 방식이 반복진행된다.
> DNA1은 분할하는 경우 오른쪽에 있는 DNA2에 정보를 하나 저장하고 자기 자신에도 정보하나를 저장하는 특징을 갖는다. 또한 DNA5는 분할할경우 자신의 정보 하나를 버린다.   

- | DNA1 | DNA2 | DNA3 | DNA4 | DNA5
---:|:---:|:---:|:---:|:---:|:---:|
0회분할 | | |◎ | | |
1회분할 | | ○ | |● | |
2회분할 |○||○●| | ●
3회분할 |○|○○●||○●●||
...|...|...|...|...|...|
> 결론적으로 세포는 자기 증식할 때 일정한 규칙이 있으므로 규칙을 반대로 적용해서 임의의 세포 DNA패턴을 보면 가장 최상위 부모의 DNA를 역추적할 수 있다. 또한 몇단계의 세포 증식을 거쳤는지도 알 수 있다.   
> 이러한 임의 DNA패턴이 주어지면 일정한 규칙의 세포 증식과정을 거쳐서 진화한다고 가정하고 진화의 가장 최상위 단계에 있는 세포의 DNA패턴을 찾아내는 프로그램을 만들어보자.   
- 입력파일의 이름은 'input.txt'
- 입력데이터는 T개의 테스트 케이스로 이뤄져 있고, T는 파일의 첫행에 주어진다.
- 각 테스트의 첫번째 행에는 DNA의 개수 N, 두번째 행에는 DNA의 패턴이 주어진다.
- 출력파일의 이름은 'output.txt'
- 세포가 자기증식을 한 과정을 모두 출력.
- 몇 회 분할했는지 'X회 분할' 이라고 출력한다.
- 의미없는 값은 음수로 변환해 나타낸다.   

최상위 부모세포의 DNA는 음수가 아닌 값을 갖는 마지막 패턴이므로 00100이다. 프로그램에서는 출력결과에서 음수를 포함하는지의 여부를 확인할 수 있어야 한다.   
분할과정을 출력하려면 음수가 아닌 출력값이 몇 번 나왔는지 확인해야 한다.   
분할과정 처음부터 음수가 나오는 경우를 고려한 처리 방법을 구현.   
   
DNA배열에서 2개의 열을 사용해 한 단계씩 추적할 때마다 서로 값을 바꿔서 사용한다.   
DNA[0][N]에는 기존의 DNA정보, DNA[1][N]에는 임의로 추적된 DNA정보를 담는다.   
추적이 완료되었다면 횟수를 1증가시키고
DNA[1]의 값이 음수가 될때까지 반복한다.


***
## 재난 관리 프로젝트
   
> 한국 정부에서는 지난 수십 년 동안 공공 건물이나 지하철같은 대중교통에서 빈번하게 발생하는 화재에 대비하기 위해 화재 발생 시 자동으로 국민들을 대피시키는 재난 관리 프로그램을 개발하기로 하고 한빛전자에 개발을 의뢰했다.   
> 재난 관리 프로그램은 공공건물이나 지하철 역사의 도면을 저장해두고 각각의 구역을 *세로 M* , *가로 N*의 직사각형 형태로 정의한다.   
> 그리고 각 공간을 상황에 따라 알파벳 기호로 나타내는데,   
> **해당 구역에 화재가 발생하면 F, 아직 화재가 발생하지 않았다면 O, 현재 위치는 Y, 탈출구는 E다.**
> Y에서 E까지의 최단거리를 구하면 되는데 *사람들이 X번 이동할때마다 상하좌우로 불이 한칸씩 번진다.*
- 입력 파일의 이름 "input.txt"
- 파일의 첫번째 해에는 세로칸 숫자인 M, 가로칸 숫자인 N, 사람들이 한번에 이동할 수 있는 값인 X가 주어진다.
- 두번째 행 이후는 M*N형태의 문자열로 건물의 초기상태가 주어진다. **화재발생구역 F, 현재위치 Y, 안전구역 O, 탈출구 E**
- 출력파일의 이름 "output.txt"
- 첫째행에는 최소 몇번의 움직임으로 탈출구까지 도달하는지 횟수 출력.
- 두번째 행에는 경로를 출력. 위 U, 아래 D, 왼쪽 L, 오른쪽 R의 조합으로 이뤄지며 중복답일 경우 하나만 출력.
   
건물의 도면을 배열에 저장. 같은 사이즈의 빈 배열을 만들기.   
MAX : 불이 난 곳   
-1 : 탈출구   
1 : 현재 위치
- | - | - | - | - 
---:|:---:|:---:|:---:|:---
MAX | 0 | 0 | 0 | -1
0 | 0 | 0 | 0 | 0
0 | 0 | 0 | 0 | 0
0 | 0 | 0 | 0 | 0
1 | 0 | MAX | MAX | 0
도면을 배열에 매칭시키고 현재 위치를 큐에 삽입, 큐에서 위치데이터를 빼내어 인접한 곳에 0이 있다면 현재 위치의 데이터값을 하나 증가시켜 그곳에 저장.
- | - | - | - | - 
---:|:---:|:---:|:---:|:---
MAX | 0 | 0 | 0 | -1
0 | 0 | 0 | 0 | 0
0 | 0 | 0 | 0 | 0
2 | 0 | 0 | 0 | 0
1 | 2 | MAX | MAX | 0
   

별도의 배열을 하나 더 선언하여 값이 증가한 곳을 확인하고 아래에서 증가되었다면 D, 왼쪽에서 증가했다면 L을 추가.   
최단 거리를 찾았을 때 D나 L같은 값을 통해 어떤 경로로 왔는지 확인용도
- | - | - | - | - 
---:|:---:|:---:|:---:|:---
- | - | - | - | -
- | - | - | - | -
- | - | - | - | -
D | - | - | - | -
- | L | - | - | -

- | - | - | - | - 
---:|:---:|:---:|:---:|:---
MAX | MAX | 0 | 0 | -1
MAX | 0 | 0 | 0 | 0
3 | 4 | 0 | 0 | 0
2 | 3 | MAX | MAX | 0
1 | MAX | MAX | MAX | MAX

- | - | - | - | - 
---:|:---:|:---:|:---:|:---
- | - | - | - | -
- | - | - | - | -
D | D | - | - | -
D | D | - | - | -
- | L | - | - | -

이 과정을 거치면 최종적으로 아래의 표처럼 배열의 내용이 채워진다.
- | - | - | - | - 
---:|:---:|:---:|:---:|:---
MAX | MAX | MAX | MAX | 9
MAX | MAX | MAX | MAX | 8
MAX | MAX | MAX | MAX | MAX
MAX | MAX | MAX | MAX | MAX
MAX | MAX | MAX | MAX | MAX

- | - | - | - | - 
---:|:---:|:---:|:---:|:---
- | - | - | D | D
- | D | D | L | L
D | D | L | - | -
D | D | - | - | -
- | L | - | - | -
***
